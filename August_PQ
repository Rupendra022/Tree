1. Balanced Binary Tree Check >- 
class Solution {
    // RADHE RADHE 
    public static int height(Node root){
        if(root==null){
            return 0 ; 
        }
    int lh = height(root.left);
    if(lh==-1) return -1 ; 
    int rh = height(root.right);
    if(rh==-1) return -1 ; 
    
    if(Math.abs(lh-rh)>1) return -1 ; 
    
    return Math.max(lh,rh)+1 ; 
        
    }
    public boolean isBalanced(Node root) {
        // code here
        
        return height(root)!=-1 ; 
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2. Binary Tree Maximum Path Sum LeetCode Hard >- 
class Solution {
    public int sum(TreeNode root , int[] ans){
        if(root==null){
            return 0 ; 
        }

        int lh = Math.max(0,sum(root.left,ans));
        int rh = Math.max(0,sum(root.right,ans));

        ans[0] = Math.max(ans[0],lh+rh+root.val);

        return Math.max(lh,rh)+root.val ;
    }
    public int maxPathSum(TreeNode root) {

      int[] ans = new int[1];
      ans[0] = Integer.MIN_VALUE ; 

      sum(root,ans);

      return ans[0];  
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------
