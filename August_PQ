1. Balanced Binary Tree Check >- 
class Solution {
    // RADHE RADHE 
    public static int height(Node root){
        if(root==null){
            return 0 ; 
        }
    int lh = height(root.left);
    if(lh==-1) return -1 ; 
    int rh = height(root.right);
    if(rh==-1) return -1 ; 
    
    if(Math.abs(lh-rh)>1) return -1 ; 
    
    return Math.max(lh,rh)+1 ; 
        
    }
    public boolean isBalanced(Node root) {
        // code here
        
        return height(root)!=-1 ; 
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2. Binary Tree Maximum Path Sum LeetCode Hard >- 
class Solution {
    public int sum(TreeNode root , int[] ans){
        if(root==null){
            return 0 ; 
        }

        int lh = Math.max(0,sum(root.left,ans));
        int rh = Math.max(0,sum(root.right,ans));

        ans[0] = Math.max(ans[0],lh+rh+root.val);

        return Math.max(lh,rh)+root.val ;
    }
    public int maxPathSum(TreeNode root) {

      int[] ans = new int[1];
      ans[0] = Integer.MIN_VALUE ; 

      sum(root,ans);

      return ans[0];  
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------
3. Symmetric Tree >- 

class Solution {
    public boolean symmetry(TreeNode l, TreeNode r){
        if(l==null && r==null){
            return true ; 
        }
        if(l==null || r==null){
            return false ; 
        }
        
        if(l.data!=r.data){
            return false ;
        }
        return symmetry(l.left,r.right) && symmetry(l.right,r.left);
    }
    public boolean isSymmetric(TreeNode root) {
        //your code goes here
        if(root==null){
            return true ; 
        }

        return symmetry(root.left,root.right);
    }
}


------------------------------------------------------------------------------------------------------------------------------------------------
4. Binary Tree >- LEVEL ORDER TRAVERSAL >- 

class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {

        List<List<Integer>> ans = new ArrayList<>();
        if(root==null) return ans ;
        Queue<TreeNode> queue = new LinkedList<>();

        queue.add(root);

        while (!queue.isEmpty()) {
            List<Integer> ds = new ArrayList<>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
                ds.add(node.val);
            }
            ans.add(new ArrayList<>(ds));
        }

        return ans;
        
    }
}



-----------------------------------------------------------------------------------------------------------------------------------------------
4. Binary Tree >- ZIGZAG LEVEL ORDER TRAVERSAL >- 
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        
        List<List<Integer>> ans = new ArrayList<>();

        if(root==null) return ans ;
        Queue<TreeNode> queue = new LinkedList<>();

        queue.add(root);
        int count = 0;

        while (!queue.isEmpty()) {
            List<Integer> ds = new ArrayList<>();
            int size = queue.size();

            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.add(node.left);
                }

                if (node.right != null) {
                    queue.add(node.right);
                }
                ds.add(node.val);
            }

            if (count % 2 != 0) {
                Collections.reverse(ds);
            }
            ans.add(new ArrayList<>(ds));
            count++;
        }

        return ans;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------
5. RIGHT VIEW OF BINARY TREE >- 

 ArrayList<Integer> ans = new ArrayList<>();
        
        Queue<Node> q = new LinkedList<>();
        q.add(root);
        
        while(!q.isEmpty()){
            
            int sz = q.size();
            
            for(int i = 0 ; i<sz ; i++){
                Node node = q.poll();
                
                if(node.left!=null) q.add(node.left);
                if(node.right!=null) q.add(node.right);
                
                if(i==sz-1) ans.add(node.data);
            }
        }
        
    return ans ; 


-----------------------------------------------------------------------------------------------------------------------------------------------
6. LEFT VIEW OF BINARY TREE >- 

 ArrayList<Integer> ans = new ArrayList<>();
        
        Queue<Node> q = new LinkedList<>();
        q.add(root);
        
        while(!q.isEmpty()){
            
            int sz = q.size();
            
            for(int i = 0 ; i<sz ; i++){
                Node node = q.poll();
                
                if(node.left!=null) q.add(node.left);
                if(node.right!=null) q.add(node.right);
                
                if(i==0) ans.add(node.data);
            }
        }
        
    return ans ;  

-----------------------------------------------------------------------------------------------------------------------------------------------
7. TOP VIEW OF BINARY TREE >- 
class Solution {
    static class Pair{
        Node node ;
        int hd ; 
        Pair(Node node , int hd){
            this.node = node ; 
            this.hd = hd ; 
        }
    }
    // Function to return a list of nodes visible from the top view
    // from left to right in Binary Tree.
    static ArrayList<Integer> topView(Node root) {
        // code here
        ArrayList<Integer> ans = new ArrayList<>();
        Queue<Pair> q = new LinkedList<>();
        
        q.add(new Pair(root,0));
        
        TreeMap<Integer,Node> map = new TreeMap<>();
        
        while(!q.isEmpty()){
            
            Pair curr = q.poll();
            
            map.putIfAbsent(curr.hd,curr.node);
            
            if(curr.node.left!=null) q.add(new Pair(curr.node.left,curr.hd-1));
            if(curr.node.right!=null) q.add(new Pair(curr.node.right,curr.hd+1));
            
            
        }
        
        for(int ele : map.keySet()){
            ans.add(map.get(ele).data);
        }
        
        return ans ;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------
8. BOTTOM VIEW OF BINARY TREE >- 
class Solution {
    class Pair{
        Node node ; 
        int hd ; 
        Pair(Node node , int hd ){
            this.node = node ; 
            this.hd = hd ; 
        }
    }
    public ArrayList<Integer> bottomView(Node root) {
        // RADHE RADHE 
        // Code here
        ArrayList<Integer> ans = new ArrayList<>();
        
        Queue<Pair> q = new LinkedList<>();
        q.add(new Pair(root,0));
        
        TreeMap<Integer,Node> map = new TreeMap<>();
        
        while(!q.isEmpty()){
            
            Pair curr = q.poll();
            
            map.put(curr.hd,curr.node);
            
         if(curr.node.left!=null) q.add(new Pair(curr.node.left,curr.hd-1));
         if(curr.node.right!=null) q.add(new Pair(curr.node.right,curr.hd+1));
        
            
        }
        
        for(int ele : map.keySet()){
            ans.add(map.get(ele).data);
        }
        
        return ans ;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------

9. COUNT OF NODES IN COMPLETE BINARY TREE >- T.C. >- O(LOGN) >- 
class Solution {
    public int lheight(TreeNode root) {
        int count = 0 ;
        while(root!=null){
            root = root.left ; 
            count++ ; 
        }
        

        return count ;
    }

    public int rheight(TreeNode root) {
        int count = 0 ;
        while(root!=null){
            root = root.right ; 
            count++ ; 
        }
        

        return count ;
    }

    public int countNodes(TreeNode root) {
        if(root==null){
            return 0 ; 
        }

        int lh = lheight(root.left);
        int rh = rheight(root.right);
        
        // for complete binary tree 
        if(lh==rh) return ((2<<(lh))-1) ; 

        else return countNodes(root.left) + countNodes(root.right) + 1 ; 
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------
10 .MIRROR TREE >- 
class Solution {
    void mirror(Node node) {
        // code here
        if(node==null) return ; 
        
        mirror(node.left);
        mirror(node.right);
        
        Node curr = node.left ; 
        node.left = node.right ; 
        node.right = curr ; 
        
        
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------
11. ROOT TO LEAF PATHS >- 
class Solution {
    public static void helper(Node root ,ArrayList<ArrayList<Integer>> ans,ArrayList<Integer> a){
        if(root==null) return ; 
        
        a.add(root.data);
        if(root.left==null && root.right==null){
            ans.add(new ArrayList<>(a));
            a.remove(a.size()-1); // to delete leaf node  
            return ;
        }
        
        helper(root.left,ans,a);
        helper(root.right,ans,a);
        a.remove(a.size()-1); // for cleanup
    }
    public static ArrayList<ArrayList<Integer>> Paths(Node root) {
        // code here
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        ArrayList<Integer> a = new ArrayList<>();
        helper(root,ans,a);
        
        return ans ;
    }
}


-----------------------------------------------------------------------------------------------------------------------------------------------
12. PRINT PATH FROM ROOT TO GIVEN NODE IN A BINARY TREE >-
public static boolean hasPath(Node root, ArrayList<Integer> arr, int x) 
    { 
        // if root is NULL 
        // there is no path 
        if (root==null) 
            return false; 
      
        // push the node's value in 'arr' 
        arr.add(root.data);     
      
        // if it is the required node 
        // return true 
        if (root.data == x)     
            return true; 
      
        // else check whether the required node lies 
        // in the left subtree or right subtree of  
        // the current node 
        if (hasPath(root.left, arr, x) || 
            hasPath(root.right, arr, x)) 
            return true; 
      
        // required node does not lie either in the  
        // left or right subtree of the current node 
        // Thus, remove current node's value from  
        // 'arr'and then return false     
        arr.remove(arr.size()-1); 
        return false;             
    } 



-----------------------------------------------------------------------------------------------------------------------------------------------
13. LOWEST COMMON ANCESTORS OF A BINARY TREE >- 
BETTER APPROACH >=
PREREQUISITE >- PRINT PATH FROM ROOT TO GIVEN NODE IN A BINARY TREE 
class Solution {
    public boolean path(ArrayList<TreeNode> a, TreeNode root, TreeNode target) {
        if (root == null)
            return false; // no path exist 

        a.add(root);
        if (root == target)
            return true;

        if (path(a, root.left, target) || path(a, root.right, target)) { // if any one is giving path
            return true;
        }
        a.remove(a.size() - 1); // backtrack 
        return false;

    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        ArrayList<TreeNode> a1 = new ArrayList<>();
        ArrayList<TreeNode> a2 = new ArrayList<>();
        path(a1, root, p);
        path(a2, root, q);

        int sz = Math.min(a1.size(), a2.size());
        for (int i = 0; i < sz; i++) {
            if (a1.get(i) != a2.get(i)) {
                return a1.get(i - 1);
            }
        }

        return a1.get(sz - 1);
    }
}


-----------------------------------------------------------------------------------------------------------------------------------------------
14. LCA OPTIMAL APPROACH >- RECURSIVE >- 
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        if (root == null || root == p || root == q)
            return root;

        TreeNode l = lowestCommonAncestor(root.left, p, q);
        TreeNode r = lowestCommonAncestor(root.right, p, q);

        if (l == null) {
            return r;
        } else if (r == null) {
            return l;
        } else {
            return root; // if both l and r are not null that means we found the result 
        }
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------
15. CHECK IF TWO NODES ARE COUSINS >- 
class Solution {
    public boolean path(Node root , int target ,ArrayList<Node> way){
        if(root==null){
            return false ; 
        }
        way.add(root);
        if(root.data==target){
            return true ; 
        }
        if(path(root.left,target,way) ||path(root.right,target,way)){
            return true ; 
        }
        way.remove(way.size()-1);
        return false ; 
        
    }

    // Returns true if the nodes with values 'a' and 'b' are cousins. Else returns false
    public boolean isCousins(Node root, int a, int b) {
        // RADHE RADHE 
        // your code here
        if(root.left==null && root.right==null){
            return false ;
        }
        // This function should return true if x and y are cousins, else return false
        
        ArrayList<Node> a1 = new ArrayList<>();
        ArrayList<Node> a2 = new ArrayList<>();
        
        path(root,a,a1);
        path(root,b,a2);
        
        
        if(a1.size()!=a2.size()){
            return false ; 
        }
        
        
        if(a1.size()>=2 && (a1.size()==a2.size() && a1.get(a1.size()-2)!=a2.get(a2.size()-2))){
            return true ; 
        }
        
        return false ;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------
16. MINIMUM DISTANCE B/W TWO NODES OF BINARY TREE >- 
APPROACH1 >- SIMPLE AND EASY TO GRASP >- 
USING ROOT TO NODE PATH AND LCA LOGICS >-
BETTER APPROACH 
class GfG {
    // helper function: get path from root to target
    public boolean path(Node root, int target, ArrayList<Integer> ans) {
        if (root == null) return false;
        
        ans.add(root.data);

        if (root.data == target) return true;

        if (path(root.left, target, ans) || path(root.right, target, ans)) {
            return true;
        }

        // backtrack if target not found in this branch
        ans.remove(ans.size() - 1);
        return false;
    }

    int findDist(Node root, int a, int b) {
        ArrayList<Integer> a1 = new ArrayList<>();
        ArrayList<Integer> a2 = new ArrayList<>();

        // find paths from root to a and root to b
        if (!path(root, a, a1) || !path(root, b, a2)) {
            return -1; // one of the nodes doesn't exist
        }

        // find LCA by comparing paths
        int i = 0;
        while (i < a1.size() && i < a2.size() && a1.get(i).equals(a2.get(i))) {
            i++;
        }

        // distance = remaining nodes in pathA + remaining nodes in pathB
        return (a1.size() - i) + (a2.size() - i);
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------
17. MINIMUM DISTANCE B/W TWO NODES OF BINARY TREE >- (GFG HARD) 
PREREQUISITE >- LCA 
RECURSIVE APPROACH 
APPROACH >- We have to calculate the minimum distance so if we do an observation then we will able to find it out that the minimum distance
b/w two nodes will always come through the lca of these two nodes.
So first of all we just find out the lca of both the nodes and then we find out the distance b/w first node and lca called it as dist1 and 
then find out the dist2 from the second node to lca.We  now return our min distance answer as the sum of the dist1 + dist2.

class GfG {
    // RADHE RADHE 
    public static Node lca(Node root , int a , int b ){
        if(root==null || root.data==a || root.data==b){
            return root ; 
        }
        
                Node l = lca(root.left,a,b);
                Node r = lca(root.right,a,b);
                
                if(l==null){
                    return r ; 
                }
                else if(r==null){
                    return l ; 
                }
                else{
                    return root ;
                }
    }
    public static int dist(Node root , int target){
        if(root==null) return -1 ; 
        if(root.data==target) return 0 ; 
        
        int l = dist(root.left,target);
        int r = dist(root.right,target);
        
        if(l==-1 && r==-1){
            return -1 ; 
        }
        else if(l==-1){
            return r+1 ; 
        }
        else{
            return l+1 ; 
        }
        
    }
    
    int findDist(Node root, int a, int b) {
        // Your code here
        
        Node LCA = lca(root,a,b);
        
        int dist1 = dist(LCA,a);
        int dist2 = dist(LCA,b);
        
        return dist1+dist2 ;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------
18. Kth Ancestor in a Binary Tree >- Using Path Approach 
class Solution {
    public boolean path(ArrayList<Integer> a , Node root , int node){
        if(root==null) return false ; 
        a.add(root.data);
        if(root.data==node) return true  ; 
        
        if(path(a,root.left,node) || path(a,root.right,node)){
            return true ; 
        }
        a.remove(a.size()-1);
        return false ; 
    }
    public int kthAncestor(Node root, int k, int node) {
        // Write your code here
        
        ArrayList<Integer> a = new ArrayList<>();
        
        path(a,root,node);
        int count = 0 ; 
        for(int i = a.size()-1 ; i>=0 ; i--){
            if(count==k){
                return a.get(i);
            }
            count++ ; 
        }
        
        return -1 ;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
19. PATH SUM 2 LEETCODE >- 
class Solution {
    public void helper(List<List<Integer>> ans, TreeNode root, List<Integer> a, int target, int sum) {
        if (root == null)
            return;
        sum += root.val;
        a.add(root.val);
        if (root.left == null && root.right == null && sum == target) {
            ans.add(new ArrayList<>(a));
        }

        helper(ans, root.left, a, target, sum);
        helper(ans, root.right, a, target, sum);
        a.remove(a.size() - 1);

    }

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<List<Integer>> ans = new ArrayList<>();

        helper(ans, root, new ArrayList<>(), targetSum, 0);
        return ans;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
20. Ancestors in Binary Tree >- GFG 
class Solution {
    public boolean path(Node root , int target , ArrayList<Integer> ds){
        if(root==null) return false ;
        ds.add(root.data);
        if(root.data==target){
            return true ; 
        }
        
        if(path(root.left,target,ds)||path(root.right,target,ds)){
            return true ; 
        }
        
        ds.remove(ds.size()-1);
        return false ;
    }

    public ArrayList<Integer> Ancestors(Node root, int target) {
        // add your code here
        ArrayList<Integer> ds = new ArrayList<>();
        
        path(root,target,ds);
        
        ds.remove(ds.size()-1);
        Collections.reverse(ds);
        return ds ;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------
