1. Balanced Binary Tree Check >- 
class Solution {
    // RADHE RADHE 
    public static int height(Node root){
        if(root==null){
            return 0 ; 
        }
    int lh = height(root.left);
    if(lh==-1) return -1 ; 
    int rh = height(root.right);
    if(rh==-1) return -1 ; 
    
    if(Math.abs(lh-rh)>1) return -1 ; 
    
    return Math.max(lh,rh)+1 ; 
        
    }
    public boolean isBalanced(Node root) {
        // code here
        
        return height(root)!=-1 ; 
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2. Binary Tree Maximum Path Sum LeetCode Hard >- 
class Solution {
    public int sum(TreeNode root , int[] ans){
        if(root==null){
            return 0 ; 
        }

        int lh = Math.max(0,sum(root.left,ans));
        int rh = Math.max(0,sum(root.right,ans));

        ans[0] = Math.max(ans[0],lh+rh+root.val);

        return Math.max(lh,rh)+root.val ;
    }
    public int maxPathSum(TreeNode root) {

      int[] ans = new int[1];
      ans[0] = Integer.MIN_VALUE ; 

      sum(root,ans);

      return ans[0];  
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------
3. Symmetric Tree >- 

class Solution {
    public boolean symmetry(TreeNode l, TreeNode r){
        if(l==null && r==null){
            return true ; 
        }
        if(l==null || r==null){
            return false ; 
        }
        
        if(l.data!=r.data){
            return false ;
        }
        return symmetry(l.left,r.right) && symmetry(l.right,r.left);
    }
    public boolean isSymmetric(TreeNode root) {
        //your code goes here
        if(root==null){
            return true ; 
        }

        return symmetry(root.left,root.right);
    }
}


------------------------------------------------------------------------------------------------------------------------------------------------
4. Binary Tree >- LEVEL ORDER TRAVERSAL >- 

class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {

        List<List<Integer>> ans = new ArrayList<>();
        if(root==null) return ans ;
        Queue<TreeNode> queue = new LinkedList<>();

        queue.add(root);

        while (!queue.isEmpty()) {
            List<Integer> ds = new ArrayList<>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
                ds.add(node.val);
            }
            ans.add(new ArrayList<>(ds));
        }

        return ans;
        
    }
}



-----------------------------------------------------------------------------------------------------------------------------------------------
4. Binary Tree >- ZIGZAG LEVEL ORDER TRAVERSAL >- 
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        
        List<List<Integer>> ans = new ArrayList<>();

        if(root==null) return ans ;
        Queue<TreeNode> queue = new LinkedList<>();

        queue.add(root);
        int count = 0;

        while (!queue.isEmpty()) {
            List<Integer> ds = new ArrayList<>();
            int size = queue.size();

            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.add(node.left);
                }

                if (node.right != null) {
                    queue.add(node.right);
                }
                ds.add(node.val);
            }

            if (count % 2 != 0) {
                Collections.reverse(ds);
            }
            ans.add(new ArrayList<>(ds));
            count++;
        }

        return ans;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------
5. RIGHT VIEW OF BINARY TREE >- 

 ArrayList<Integer> ans = new ArrayList<>();
        
        Queue<Node> q = new LinkedList<>();
        q.add(root);
        
        while(!q.isEmpty()){
            
            int sz = q.size();
            
            for(int i = 0 ; i<sz ; i++){
                Node node = q.poll();
                
                if(node.left!=null) q.add(node.left);
                if(node.right!=null) q.add(node.right);
                
                if(i==sz-1) ans.add(node.data);
            }
        }
        
    return ans ; 


-----------------------------------------------------------------------------------------------------------------------------------------------
6. LEFT VIEW OF BINARY TREE >- 

 ArrayList<Integer> ans = new ArrayList<>();
        
        Queue<Node> q = new LinkedList<>();
        q.add(root);
        
        while(!q.isEmpty()){
            
            int sz = q.size();
            
            for(int i = 0 ; i<sz ; i++){
                Node node = q.poll();
                
                if(node.left!=null) q.add(node.left);
                if(node.right!=null) q.add(node.right);
                
                if(i==0) ans.add(node.data);
            }
        }
        
    return ans ;  

-----------------------------------------------------------------------------------------------------------------------------------------------
7. TOP VIEW OF BINARY TREE >- 
class Solution {
    static class Pair{
        Node node ;
        int hd ; 
        Pair(Node node , int hd){
            this.node = node ; 
            this.hd = hd ; 
        }
    }
    // Function to return a list of nodes visible from the top view
    // from left to right in Binary Tree.
    static ArrayList<Integer> topView(Node root) {
        // code here
        ArrayList<Integer> ans = new ArrayList<>();
        Queue<Pair> q = new LinkedList<>();
        
        q.add(new Pair(root,0));
        
        TreeMap<Integer,Node> map = new TreeMap<>();
        
        while(!q.isEmpty()){
            
            Pair curr = q.poll();
            
            map.putIfAbsent(curr.hd,curr.node);
            
            if(curr.node.left!=null) q.add(new Pair(curr.node.left,curr.hd-1));
            if(curr.node.right!=null) q.add(new Pair(curr.node.right,curr.hd+1));
            
            
        }
        
        for(int ele : map.keySet()){
            ans.add(map.get(ele).data);
        }
        
        return ans ;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------
8. BOTTOM VIEW OF BINARY TREE >- 
class Solution {
    class Pair{
        Node node ; 
        int hd ; 
        Pair(Node node , int hd ){
            this.node = node ; 
            this.hd = hd ; 
        }
    }
    public ArrayList<Integer> bottomView(Node root) {
        // RADHE RADHE 
        // Code here
        ArrayList<Integer> ans = new ArrayList<>();
        
        Queue<Pair> q = new LinkedList<>();
        q.add(new Pair(root,0));
        
        TreeMap<Integer,Node> map = new TreeMap<>();
        
        while(!q.isEmpty()){
            
            Pair curr = q.poll();
            
            map.put(curr.hd,curr.node);
            
         if(curr.node.left!=null) q.add(new Pair(curr.node.left,curr.hd-1));
         if(curr.node.right!=null) q.add(new Pair(curr.node.right,curr.hd+1));
        
            
        }
        
        for(int ele : map.keySet()){
            ans.add(map.get(ele).data);
        }
        
        return ans ;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------

9. COUNT OF NODES IN COMPLETE BINARY TREE >- T.C. >- O(LOGN) >- 
class Solution {
    public int lheight(TreeNode root) {
        int count = 0 ;
        while(root!=null){
            root = root.left ; 
            count++ ; 
        }
        

        return count ;
    }

    public int rheight(TreeNode root) {
        int count = 0 ;
        while(root!=null){
            root = root.right ; 
            count++ ; 
        }
        

        return count ;
    }

    public int countNodes(TreeNode root) {
        if(root==null){
            return 0 ; 
        }

        int lh = lheight(root.left);
        int rh = rheight(root.right);
        
        // for complete binary tree 
        if(lh==rh) return ((2<<(lh))-1) ; 

        else return countNodes(root.left) + countNodes(root.right) + 1 ; 
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------
10 .MIRROR TREE >- 
class Solution {
    void mirror(Node node) {
        // code here
        if(node==null) return ; 
        
        mirror(node.left);
        mirror(node.right);
        
        Node curr = node.left ; 
        node.left = node.right ; 
        node.right = curr ; 
        
        
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------
11. ROOT TO LEAF PATHS >- 
class Solution {
    public static void helper(Node root ,ArrayList<ArrayList<Integer>> ans,ArrayList<Integer> a){
        if(root==null) return ; 
        
        a.add(root.data);
        if(root.left==null && root.right==null){
            ans.add(new ArrayList<>(a));
            a.remove(a.size()-1); // to delete leaf node  
            return ;
        }
        
        helper(root.left,ans,a);
        helper(root.right,ans,a);
        a.remove(a.size()-1); // for cleanup
    }
    public static ArrayList<ArrayList<Integer>> Paths(Node root) {
        // code here
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        ArrayList<Integer> a = new ArrayList<>();
        helper(root,ans,a);
        
        return ans ;
    }
}


-----------------------------------------------------------------------------------------------------------------------------------------------
12. PRINT PATH FROM ROOT TO GIVEN NODE IN A BINARY TREE >-
public static boolean hasPath(Node root, ArrayList<Integer> arr, int x) 
    { 
        // if root is NULL 
        // there is no path 
        if (root==null) 
            return false; 
      
        // push the node's value in 'arr' 
        arr.add(root.data);     
      
        // if it is the required node 
        // return true 
        if (root.data == x)     
            return true; 
      
        // else check whether the required node lies 
        // in the left subtree or right subtree of  
        // the current node 
        if (hasPath(root.left, arr, x) || 
            hasPath(root.right, arr, x)) 
            return true; 
      
        // required node does not lie either in the  
        // left or right subtree of the current node 
        // Thus, remove current node's value from  
        // 'arr'and then return false     
        arr.remove(arr.size()-1); 
        return false;             
    } 



-----------------------------------------------------------------------------------------------------------------------------------------------
13. LOWEST COMMON ANCESTORS OF A BINARY TREE >- 
BETTER APPROACH >=
PREREQUISITE >- PRINT PATH FROM ROOT TO GIVEN NODE IN A BINARY TREE 
class Solution {
    public boolean path(ArrayList<TreeNode> a, TreeNode root, TreeNode target) {
        if (root == null)
            return false; // no path exist 

        a.add(root);
        if (root == target)
            return true;

        if (path(a, root.left, target) || path(a, root.right, target)) { // if any one is giving path
            return true;
        }
        a.remove(a.size() - 1); // backtrack 
        return false;

    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        ArrayList<TreeNode> a1 = new ArrayList<>();
        ArrayList<TreeNode> a2 = new ArrayList<>();
        path(a1, root, p);
        path(a2, root, q);

        int sz = Math.min(a1.size(), a2.size());
        for (int i = 0; i < sz; i++) {
            if (a1.get(i) != a2.get(i)) {
                return a1.get(i - 1);
            }
        }

        return a1.get(sz - 1);
    }
}


-----------------------------------------------------------------------------------------------------------------------------------------------
